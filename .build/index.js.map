{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["import { Telegraf } from 'telegraf';\nimport { scrapContent, Content } from './scraper';\nimport { saveContent } from './github';\n\nconst botToken: string | undefined = process.env.BOT_TOKEN\n\nif (botToken === undefined) {\n  console.error('missing bot token');\n  process.exit();\n}\n\nconst bot = new Telegraf(botToken);\nconst irfanTelegramID: number = Number(process.env.IRFAN_TELEGRAM_ID)\n\nbot.command('whoami', ctx => {\n  ctx.reply('I am a telegram bot that is used by @irfansppp to bookmark any content from the web to his second brain.');\n});\n\nbot.on('message', async ctx => {\n  if (ctx.from.id != irfanTelegramID) {\n    ctx.reply(\"I don't allow to proceed your request!\");\n    return;\n  }\n\n  if (!ctx.message) {\n    ctx.reply(\"I don't get any message!\");\n    return;\n  }\n\n  const messageEntities = ctx.message?.entities;\n  const text = ctx.message?.text?.toLowerCase();\n\n  if (!Array.isArray(messageEntities)) {\n    ctx.reply(\"Sorry boss, I don't understand your message!\")\n    return;\n  }\n\n  const urls: Array<string> = [];\n  const tags: Array<string> = [];\n\n  for (let i = 0; i < messageEntities.length; i++) {\n    const entity = messageEntities[i];\n    const idxFrom: number = entity.offset;\n    const idxTo: number = idxFrom + entity.length;\n    const entityText: string = text.substring(idxFrom, idxTo);\n    const entityType: string = entity.type;\n\n    if (entityType === 'hashtag') {\n      tags.push(entityText.substring(1));\n    }\n    if (entityType === 'url') {\n      urls.push(entityText);\n    }\n  }\n\n\n  const results = { 'failed': [], 'succeed': [] }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    try {\n      const urlContent: Content = await scrapContent(url);\n      await saveContent(urlContent, tags);\n      results.succeed.push(url as never);\n    } catch (err) {\n      console.error(err);\n      results.failed.push(url as never);\n    }\n  }\n\n  const resultsAsText = (): string => {\n    let succeedText = results.succeed.join('\\n');\n    let failedText = results.failed.join('\\n');\n    if (succeedText === \"\") {\n      return `FAILED TO BOOKMARK: ${failedText}`\n    }\n    if (failedText === \"\") {\n      return `SUCCEED TO BOOKMARK: ${succeedText}`\n    }\n    return `SUCCEED TO BOOKMARKt: ${succeedText}\\n\n            FAILED TO BOOKMARK:${failedText}`\n  }\n  ctx.reply(resultsAsText());\n});\n\n\n\nbot.launch();\n\nprocess.once('SIGINT', () => bot.stop('SIGINT'))\nprocess.once('SIGTERM', () => bot.stop('SIGTERM'))"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA,sBAAyB;AACzB,qBAAsC;AACtC,oBAA4B;AAE5B,MAAM,WAA+B,QAAQ,IAAI;AAEjD,IAAI,aAAa,QAAW;AAC1B,UAAQ,MAAM;AACd,UAAQ;AAAA;AAGV,MAAM,MAAM,IAAI,yBAAS;AACzB,MAAM,kBAA0B,OAAO,QAAQ,IAAI;AAEnD,IAAI,QAAQ,UAAU,SAAO;AAC3B,MAAI,MAAM;AAAA;AAGZ,IAAI,GAAG,WAAW,OAAM,QAAO;AAlB/B;AAmBE,MAAI,IAAI,KAAK,MAAM,iBAAiB;AAClC,QAAI,MAAM;AACV;AAAA;AAGF,MAAI,CAAC,IAAI,SAAS;AAChB,QAAI,MAAM;AACV;AAAA;AAGF,QAAM,kBAAkB,UAAI,YAAJ,mBAAa;AACrC,QAAM,OAAO,gBAAI,YAAJ,mBAAa,SAAb,mBAAmB;AAEhC,MAAI,CAAC,MAAM,QAAQ,kBAAkB;AACnC,QAAI,MAAM;AACV;AAAA;AAGF,QAAM,OAAsB;AAC5B,QAAM,OAAsB;AAE5B,WAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC/C,UAAM,SAAS,gBAAgB;AAC/B,UAAM,UAAkB,OAAO;AAC/B,UAAM,QAAgB,UAAU,OAAO;AACvC,UAAM,aAAqB,KAAK,UAAU,SAAS;AACnD,UAAM,aAAqB,OAAO;AAElC,QAAI,eAAe,WAAW;AAC5B,WAAK,KAAK,WAAW,UAAU;AAAA;AAEjC,QAAI,eAAe,OAAO;AACxB,WAAK,KAAK;AAAA;AAAA;AAKd,QAAM,UAAU,EAAE,UAAU,IAAI,WAAW;AAC3C,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,MAAM,KAAK;AACjB,QAAI;AACF,YAAM,aAAsB,MAAM,iCAAa;AAC/C,YAAM,+BAAY,YAAY;AAC9B,cAAQ,QAAQ,KAAK;AAAA,aACd,KAAP;AACA,cAAQ,MAAM;AACd,cAAQ,OAAO,KAAK;AAAA;AAAA;AAIxB,QAAM,gBAAgB,MAAc;AAClC,QAAI,cAAc,QAAQ,QAAQ,KAAK;AACvC,QAAI,aAAa,QAAQ,OAAO,KAAK;AACrC,QAAI,gBAAgB,IAAI;AACtB,aAAO,uBAAuB;AAAA;AAEhC,QAAI,eAAe,IAAI;AACrB,aAAO,wBAAwB;AAAA;AAEjC,WAAO,yBAAyB;AAAA;AAAA,iCACH;AAAA;AAE/B,MAAI,MAAM;AAAA;AAKZ,IAAI;AAEJ,QAAQ,KAAK,UAAU,MAAM,IAAI,KAAK;AACtC,QAAQ,KAAK,WAAW,MAAM,IAAI,KAAK;",
  "names": []
}
